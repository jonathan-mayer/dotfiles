#
# ~/.bashrc
#

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

alias ls='ls --color=auto'
alias grep='grep --color=auto'

export EDITOR=vim
export HISTSIZE=-1
export HISTFILESIZE=-1

export PATH=/usr/local/go/bin:$PATH
export PATH=$PATH:$HOME/go/bin

export LC_ALL="en_US.UTF-8"

update-go() {
    VERSION=$(curl -s https://go.dev/VERSION?m=text | head -n 1)
    wget https://go.dev/dl/${VERSION}.linux-amd64.tar.gz -O /tmp/go.tar.gz --quiet -o /dev/null
    sudo rm -rf /usr/local/go
    sudo tar -C /usr/local -xzf /tmp/go.tar.gz
    rm /tmp/go.tar.gz
}

dotenv() {
    local env_file="${1:-.env}"
    if [[ -f "$env_file" ]]; then
        export $(grep -v ^# "$env_file" | xargs)
    else
        echo "File $env_file not found!"
    fi
}

export PATH=$PATH:$HOME/.platformio/packages/toolchain-riscv32-esp/bin

. "$HOME/.cargo/env"

eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"

ctx() {
    if [ $# -eq 0 ]; then # command was run without arguments
        kubectl config current-context 2>/dev/null
        kubectl config get-contexts
    elif [ -z "$1" ]; then
        kubectl config unset current-context
    else
        kubectl config use-context "$1"
    fi
}

alias pre-commit-install="pre-commit install" \
    pre-commit-uninstall="pre-commit uninstall" \
    pre-commitinstall="pre-commit install" \
    pre-commituninstall="pre-commit uninstall" \
    pci="pre-commit install" \
    pcu="pre-commit uninstall" \
    pc-run="pre-commit run --all-files" \
    pc="pre-commit" \
    pcr="pre-commit run --all-files"

alias lines-changed="git diff --stat main --cached -- . ':(exclude)**/package-lock.json'"
alias lines-staged="git diff --stat HEAD --cached -- . ':(exclude)**/package-lock.json'"
alias lines-total="git ls-files --others --exclude-standard --cached -z | grep -zv 'package\.json\|package-lock\.json' | xargs -0 wc -l"
alias lines-total-go="find . -name '*' -type f | grep -e '\.go$' | grep -ve '_test\.go$' | xargs wc -l"

alias reload="source ~/.bashrc"
alias change="code ~/.bashrc"

command_not_found_handle() {
    # Invoke the default command-not-found handler (if it exists)
    if [ -x /usr/lib/command-not-found ]; then
        /usr/lib/command-not-found "$1"
    else
        echo "$1: command not found"
    fi

    #Custom logic
    if [ $# -eq 1 ]; then # unknown command was run without arguments
        echo "--------------------------------------------------------"
        echo "Detected possible clear alias. Type 'clear add' to add '$1' as an clear alias."
        echo "$1" >/tmp/possible_clear_alias.txt
    fi

    return 127
}
clear() {
    if [ ! -f "/tmp/possible_clear_alias.txt" ] || [ ! -s "/tmp/possible_clear_alias.txt" ] || [ ! $# -eq 1 ]; then
        bash -c clear
        return 1
    fi

    local POSSIBLE_CLEAR_ALIAS=$(cat "/tmp/possible_clear_alias.txt")

    echo "alias $POSSIBLE_CLEAR_ALIAS='clear'" >>~/.clear_aliases
    source ~/.clear_aliases
    echo "Clear alias '$POSSIBLE_CLEAR_ALIAS' added to ~/.clear_aliases"

    local untrimmed=$(wc -l <~/.clear_aliases)
    awk -i inplace '!seen[$0]++' ~/.clear_aliases
    local now=$(wc -l <~/.clear_aliases)
    echo "Removed $((untrimmed - now)) duplicate clear aliases from ~/.clear_aliases"

    echo "~/.clear_aliases now contains $now aliases"
    echo "If this was a mistake type 'ohno' to remove the alias"
    rm /tmp/possible_clear_alias.txt
    return 0
}
ohno() {
    if [ ! -f "$HOME/.clear_aliases" ] || [ ! -s "$HOME/.clear_aliases" ]; then
        echo "No clear aliases set yet."
        return 1
    fi

    local removedAlias=$(
        sed -n '$ s/^alias \([^=]*\)=.*/\1/p' ~/.clear_aliases
        sed -i '$d' ~/.clear_aliases
    )
    source ~/.clear_aliases
    unalias $removedAlias
    echo "Removed clear alias '$removedAlias' from ~/.clear_aliases"
    echo "~/.clear_aliases now contains $(wc -l <~/.clear_aliases) aliases"
    return 0
}
if [ -f ~/.clear_aliases ]; then
    . ~/.clear_aliases
fi

color_red=$'\e[31m'
color_yellow=$'\e[33m'
color_reset=$'\e[0m'
# delete-local-refs deletes all local refs whose remote ref was deleted on the remote
delete-local-refs() {
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    default_branch=$(git remote show origin | grep 'HEAD branch' | awk '{print $NF}')

    git fetch -p # prune all no longer existing remote refs
    # iterate over all local refs with no remote ref
    for branch in $(git for-each-ref --format '%(refname) track:%(upstream:track) upstream:%(upstream:short)' refs/heads | awk '$2 == "track:[gone]" || $3 == "upstream:" {sub("refs/heads/", "", $1); print $1}'); do
        if [[ "$branch" == "$current_branch" ]]; then
            # inform user of being on branch which is about to be deleted
            read -p "${color_red}You are currently on branch '$branch'.${color_reset} Do you want to checkout '$default_branch' to be able to delete it? (yes/no) " confirm
            if [[ "${confirm,,}" == "yes" ]]; then
                # check out main
                git checkout $default_branch
                echo "Checked out main."
            else
                # skip branch
                echo "Skipped branch '$branch'."
                continue
            fi
        fi

        # ask user for permission to delete branch
        if [[ $(git for-each-ref --format '%(upstream:short)' refs/heads/$branch) == "" ]]; then
            read -p "${color_red}Do you want to delete the local branch '$branch'? (This branch only exists locally.)${color_reset} (y/n) " confirm
        else
            read -p "${color_yellow}Do you want to delete the local branch '$branch'?${color_reset} (y/n) " confirm
        fi

        if [[ $confirm == [yY] ]]; then
            # delete branch
            git branch -D "$branch"
            echo "Deleted branch '$branch'."
        else
            # skip branch
            echo "Skipped branch '$branch'."
            continue
        fi
    done

    mapfile -t stash_list < <(git stash list | tac)
    if [[ ${#stash_list[@]} -gt 0 ]]; then
        for stash in "${stash_list[@]}"; do
            stash_id=$(echo "$stash" | awk '{print $1}' | tr -d ':')
            stash_desc=$(echo "$stash" | cut -d':' -f2- | sed 's/^ //')
            read -p "${color_yellow}Do you want to delete stash '$stash_id' ($stash_desc)?${color_reset} (y/n) " confirm
            if [[ $confirm == [yY] ]]; then
                git stash drop "$stash_id"
                echo "Deleted stash '$stash_id'."
            else
                echo "Skipped stash '$stash_id' ($stash_desc)."
            fi
        done
    fi

    echo "All branches and stashes checked."
}

COLOR_RESET="\[\e[m\]"
COLOR_BOLD_CYAN="\[\e[1;36m\]"
COLOR_BOLD_GREEN="\[\e[1;32m\]"
COLOR_BOLD_BLUE="\[\e[1;34m\]"
COLOR_BOLD_RED="\[\e[1;31m\]"

ctx-prompt() {
    CONTEXT=$(kubectl config current-context 2>/dev/null)
    if [ -z "$CONTEXT" ]; then
        echo "${COLOR_BOLD_RED}none${COLOR_RESET}"
    else
        echo "${COLOR_BOLD_CYAN}$CONTEXT${COLOR_RESET}"
    fi
}

TIME_PROMPT="\A"
USER_PROMPT="$COLOR_BOLD_GREEN\u$COLOR_RESET"
WD_PROMPT="$COLOR_BOLD_BLUE\w$COLOR_RESET"

prompter() {
    export PS1="$TIME_PROMPT $USER_PROMPT:$WD_PROMPT $(ctx-prompt)\$ "
}

PROMPT_COMMAND=prompter

export GOPRIVATE=gitlab.devops.telekom.de/*
export GO111MODULE=on
export GOPROXY=https://proxy.golang.org,direct
export PATH=$PATH:$HOME/go/bin # for bins installed by go

alias newlinters="golangci-lint linters | awk '/Disabled by your configuration linters:/,/^\s*$/' | grep -v '\[deprecated\]'"

alias update="sudo pacman -Syu --noconfirm && brew upgrade"

export GOPRIVATE=github.com # to get private repos
