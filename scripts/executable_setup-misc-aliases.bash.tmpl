#! /bin/bash

# Update Alias
{{- if eq .chezmoi.osRelease.id "arch" }}
alias update="sudo pacman -Syu --noconfirm && yay -Syu --rebuildall --noconfirm && brew upgrade && flatpak update -y"
{{- else if eq .chezmoi.osRelease.id "fedora" }}
alias update="sudo dnf upgrade --refresh -y && brew upgrade && flatpak update -y"
{{- else }}
alias update="sudo apt update && sudo apt upgrade -y && brew upgrade"
{{- end }}

# Pre-Commit Aliases
alias pci="pre-commit install" \
    pcu="pre-commit uninstall" \
    pc="pre-commit" \
    pcr="pre-commit run --all-files"

# Lines Changed Aliases
alias lines-changed="git diff --stat main --cached -- . ':(exclude)**/package-lock.json'"
alias lines-staged="git diff --stat HEAD --cached -- . ':(exclude)**/package-lock.json'"
alias lines-total="git ls-files --others --exclude-standard --cached -z | grep -zv 'package\.json\|package-lock\.json' | xargs -0 wc -l"
alias lines-total-go="find . -name '*' -type f | grep -e '\.go$' | grep -ve '_test\.go$' | xargs wc -l"

# Dotenv Alias
dotenv() {
    local env_file="${1:-.env}"
    if [[ -f "$env_file" ]]; then
        export $(grep -v ^# "$env_file" | xargs)
    else
        echo "File $env_file not found!"
    fi
}

# Kubernetes Context Alias
ctx() {
    if [ $# -eq 0 ]; then # command was run without arguments
        kubectl config current-context 2>/dev/null
        kubectl config get-contexts
    elif [ -z "$1" ]; then
        kubectl config unset current-context
    else
        kubectl config use-context "$1"
    fi
}
_ctx() {
  [[ $COMP_CWORD -eq 1 ]] &&
    COMPREPLY=( $(compgen -W "$(kubectl config get-contexts -o name)" -- "${COMP_WORDS[1]}") )
}
complete -F _ctx ctx

# ls Aliases
alias ll="ls -alF"
alias la="ls -A"

# kubectl alias
alias k=kubectl

# copy dir alias
alias cp="cp -r"

# btop alias
alias htop="echo use btop instead"

# delete empty directories
alias delete-empty-dirs="find . -type d -empty -delete"

# open in browser
browser() {
    local opener="${BROWSER:-xdg-open}"
    echo "Opening: $1"
    "$opener" "$1" >/dev/null 2>&1
}

# git goto main
gitmain() {
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  if [[ "$current_branch" != "main" && "$current_branch" != "master" ]]; then
    git fetch origin main:main
    git checkout main
  else
    git pull origin main
  fi
  delete-local-refs
}

# git open repo in browser
gitopen() {
    local dir="${1:-.}"
    
    # Verify it's a git repository
    if [[ ! -d "$dir/.git" ]]; then
        echo "Error: '$dir' is not a git repository." >&2
        return 1
    fi

    # Save current directory and switch to target
    local orig_dir="$(pwd)"
    cd "$dir" || return 1

    # normalize repo url
    local repo_url
    repo_url=$(git remote get-url origin)

    # normalize ssh (with and without protocol) and http urls
    if [[ "$repo_url" =~ ^ssh://git@(.+)\.git$ ]]; then
        repo_url="https://${BASH_REMATCH[1]}"
    elif [[ "$repo_url" =~ ^git@([^:]+):(.+)\.git$ ]]; then
        repo_url="https://${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    elif [[ "$repo_url" =~ ^https://.+\.git$ ]]; then
        repo_url="${repo_url%.git}"
    fi

    # Open Repo in browser
    browser "$repo_url"

    # return to original directory
    cd "$orig_dir"
}
complete -d gitopen

# git branch and commit
gitcb() {
    local message="$*" # something like "fix: something again"

    if [[ -z "$message" ]]; then
        echo "Usage: gitcb \"<commit message>\""
        return 1
    fi

    # check if user is not currently on main
    local current_branch
    current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)

    if [[ "$current_branch" != "main" && "$current_branch" != "master" ]]; then
        echo "You are currently on branch: $current_branch."
        echo "Typically you use this command (git commit and branch) for a single commit change that requires branching."
        echo "If this wasn't intentional you might want to checkout main using 'gitmain'."
        read -rp "Continue creating a new branch from here? [y/N] " confirm
        case "$confirm" in
            [yY][eE][sS]|[yY]) ;;
            *) echo "Aborted."; return 1 ;;
        esac
    fi

    # convert message to "fix/something-again" for branch
    # logic:
    #   sed: try converting ": " to "/" or keep original string
    #   tr: replace " " with "-"
    #   tr: convert to lowercase
    local branch=$(echo "$message" | sed -E 's/^([a-z]+):[[:space:]]*(.*)$/\1\/\2/' | tr ' ' '-' | tr '[:upper:]' '[:lower:]') 

    git switch -c "$branch"
    git add .
    git commit -nm "$message"
    git push -u origin "$branch"

    gitopen
}
_gitcb() {
  COMP_WORDBREAKS=${COMP_WORDBREAKS//:}
  # declare -p COMP_CWORD COMP_WORDS # DEBUG

  [[ $COMP_CWORD -eq 1 ]] &&
    COMPREPLY=( $(compgen -W "feat: chore: revert: fix: refactor: test: docs: style: perf:" -- "${COMP_WORDS[1]}") )
  [[ $COMP_CWORD -eq 2 ]] &&
    COMPREPLY=( $(compgen -W "add adjust rm remove include bump sw switch fix" -- "${COMP_WORDS[2]}") )
}
complete -F _gitcb gitcb

# automatic semver tagging
gittag() {
  local type=$1
  local bump=$2

  if [[ -z "$type" || -z "$bump" ]]; then
    echo "Usage: gittag <release|rc> <major|minor|patch>"
    return 1
  fi

  git fetch --tags

  # get latest release tag (exclude RCs)
  local latest_release_tag
  latest_release_tag=$(git tag --list | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1)

  # set base version if no release tags exist
  if [[ -z "$latest_release_tag" ]]; then
    if [[ "$type" == "release" ]]; then
      latest_release_tag="0.0.0"
    else
      # for RC with no releases, use 0.0.0 as base
      latest_release_tag="0.0.0"
    fi
  fi

  IFS='.' read -r major minor patch <<< "$latest_release_tag"

  # bump the version appropriately
  case "$bump" in
    major)
      ((major++))
      minor=0
      patch=0
      ;;
    minor)
      ((minor++))
      patch=0
      ;;
    patch)
      ((patch++))
      ;;
    *)
      echo "Invalid bump type: $bump (must be major|minor|patch)"
      return 1
      ;;
  esac

  local new_tag base_rc latest_rc_tag rc_number warn_msg continue_msg
  base_rc="${major}.${minor}.${patch}"
  current_branch=$(git rev-parse --abbrev-ref HEAD)

  if [[ "$type" == "release" ]]; then
    new_tag="$base_rc"
    if [[ "$current_branch" != "main" && "$current_branch" != "master" ]]; then
      warn_msg="Your selected type 'release' is typically used on main/master branches.
If this wasn't intentional you might want to checkout main using 'gitmain'."
      continue_msg="Continue creating release tag on this commit? [y/N] "
    fi
  elif [[ "$type" == "rc" ]]; then
    # Match both "1.2.3rc1" and "1.2.3-rc1"
    latest_rc_tag=$(git tag --list | grep -E "^${base_rc}(-?rc)[0-9]+$" | sort -V | tail -n1)

    if [[ -z "$latest_rc_tag" ]]; then
      new_tag="${base_rc}-rc1"
    else
      # Extract rc number (works for both formats)
      rc_number=$(echo "$latest_rc_tag" | sed -E "s/^${base_rc}-?rc([0-9]+)$/\1/")
      ((rc_number++))
      new_tag="${base_rc}-rc${rc_number}"
    fi

    if [[ "$current_branch" == "main" || "$current_branch" == "master" ]]; then
      warn_msg="Your selected type 'rc' is typically used on feature branches.
If this wasn't intentional you might want to use the 'release' type."
      continue_msg="Continue creating rc tag on this commit? [y/N] "
    fi
  else
    echo "Invalid type: $type (must be release|rc)"
    return 1
  fi

  # If a warning was prepared, show it and confirm
  if [[ -n "$warn_msg" ]]; then
      echo "You are currently on branch: $current_branch."
      echo "$warn_msg"
      read -rp "$continue_msg" confirm
      case "$confirm" in
          [yY][eE][sS]|[yY]) ;;
          *) echo "Aborted."; return 1 ;;
      esac
  fi

  # create and push the tag
  git tag "$new_tag"
  git push origin "$new_tag"
  echo "Created tag: $new_tag"
}
_gittag_complete() {
  local cur prev
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  # first argument suggestions
  if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( $(compgen -W "release rc" -- "$cur") )
    return 0
  fi

  # second argument suggestions
  if [[ $COMP_CWORD -eq 2 ]]; then
    COMPREPLY=( $(compgen -W "major minor patch" -- "$cur") )
    return 0
  fi
}
complete -F _gittag_complete gittag

# flux reconcile ssp component
reconcilecomponent() {
  local component="${1:-$(basename "$(pwd)")}"
  echo "Reconciling: $component"
  flux reconcile kustomization --with-source gitrepositories
  flux reconcile kustomization --with-source ssp-namespaces
  flux reconcile kustomization --with-source $component
  flux reconcile helmrelease --with-source -n $component $component
}
