#! /bin/bash

# Update Alias
{{- if eq .chezmoi.osRelease.id "arch" }}
alias update="sudo pacman -Syu --noconfirm && yay -Syu --rebuildall --noconfirm && brew upgrade && flatpak update -y"
{{- else if eq .chezmoi.osRelease.id "fedora" }}
alias update="sudo dnf upgrade --refresh -y && brew upgrade && flatpak update -y"
{{- else }}
alias update="sudo apt update && sudo apt upgrade -y && brew upgrade"
{{- end }}

# Pre-Commit Aliases
alias pci="pre-commit install" \
    pcu="pre-commit uninstall" \
    pc="pre-commit" \
    pcr="pre-commit run --all-files"

# Lines Changed Aliases
alias lines-changed="git diff --stat main --cached -- . ':(exclude)**/package-lock.json'"
alias lines-staged="git diff --stat HEAD --cached -- . ':(exclude)**/package-lock.json'"
alias lines-total="git ls-files --others --exclude-standard --cached -z | grep -zv 'package\.json\|package-lock\.json' | xargs -0 wc -l"
alias lines-total-go="find . -name '*' -type f | grep -e '\.go$' | grep -ve '_test\.go$' | xargs wc -l"

# Dotenv Alias
dotenv() {
    local env_file="${1:-.env}"
    if [[ -f "$env_file" ]]; then
        export $(grep -v ^# "$env_file" | xargs)
    else
        echo "File $env_file not found!"
    fi
}

# Kubernetes Context Alias
ctx() {
    if [ $# -eq 0 ]; then # command was run without arguments
        kubectl config current-context 2>/dev/null
        kubectl config get-contexts
    elif [ -z "$1" ]; then
        kubectl config unset current-context
    else
        kubectl config use-context "$1"
    fi
}
_ctx() {
  [[ $COMP_CWORD -eq 1 ]] &&
    COMPREPLY=( $(compgen -W "$(kubectl config get-contexts -o name)" -- "${COMP_WORDS[1]}") )
}
complete -F _ctx ctx

# ls Aliases
alias ll="ls -alF"
alias la="ls -A"

# kubectl alias
alias k=kubectl

# copy dir alias
alias cp="cp -r"

# dev path roots helper
export dev_dir="$HOME/dev"
export main_dir="$HOME/dev/ssp"
export dev_dir_name="$(basename -- "$dev_dir")"
export main_dir_name="$(basename -- "$main_dir")"
export gitlab_group="ssp"
_dev_path() {
  local p="$1"
  if [[ "$p" == "chezmoi" ]]; then
    chezmoi source-path
  elif [[ "$p" != /* && "$p" != ./* && "$p" != . && "$p" != ../* && "$p" != .. ]]; then
    if [[ "$p" == "$main_dir_name" ]]; then
      printf '%s\n' "$main_dir"
    elif [[ "$p" == "$main_dir_name"/* ]]; then
      p="${p#"$main_dir_name"/}"
      printf '%s\n' "$main_dir/$p"
    elif [[  "$p" == dev/* ]]; then
      p="${p#dev/}"
      printf '%s\n' "$dev_dir/$p"
    elif [[ "$p" == "$dev_dir_name"/* ]]; then
      p="${p#"$dev_dir_name"/}"
      printf '%s\n' "$dev_dir/$p"
    elif [[ "$p" == dev || "$p" == "$dev_dir_name" ]]; then
      printf '%s\n' "$dev_dir"
    else
      printf '%s\n' "$main_dir/$p"
    fi
  else
    printf '%s\n' "$p"
  fi
}
_dev_path_completion() { # TODO fallback to normal file completion
  local cur
  cur="${COMP_WORDS[COMP_CWORD]}"

  [[ "$cur" == -* ]] && return 0

  COMPREPLY=()

  compopt -o filenames -o nospace 2>/dev/null

  if [[ -z "$cur" || ( "$cur" != /* && "$cur" != ./* && "$cur" != ../* && "$cur" != . && "$cur" != .. && "$cur" != */* ) ]]; then
    local -a vwords=("chezmoi" "dev/" "${dev_dir_name}/" "${main_dir_name}/")
    COMPREPLY+=($(compgen -W "${vwords[*]}" -- "$cur"))
  fi

  _dev_path_completion_under() {
    local base="$1" vprefix="$2" rest="$3"
    local m out real
    local IFS=$'\n'

    for m in $(compgen -f -- "$base/$rest"); do
      real="$m"

      out="${m#$base/}"
      out="${out#$base}"

      # Append slash if the real path is a directory
      if [[ -d "$real" ]]; then
        out="${out}/"
      fi

      if [[ -n "$vprefix" ]]; then
        COMPREPLY+=("$vprefix/$out")
      else
        COMPREPLY+=("$out")
      fi
    done
  }

  # Special token "chezmoi" is exact-only in the wrapper
  if [[ "$cur" == chezmoi* ]]; then
    COMPREPLY=($(compgen -W "chezmoi" -- "$cur"))
    return 0
  fi

  # Absolute / explicit relative paths: normal filename completion
  if [[ "$cur" == /* || "$cur" == ./* || "$cur" == ../* ]]; then
    COMPREPLY=($(compgen -f -- "$cur"))
    return 0
  fi

  case "$cur" in
    dev/*)
      _dev_path_completion_under "$dev_dir" "dev" "${cur#dev/}"
      ;;
    "${dev_dir_name}"/*)
      _dev_path_completion_under "$dev_dir" "$dev_dir_name" "${cur#"$dev_dir_name"/}"
      ;;
    "${main_dir_name}"/*)
      _dev_path_completion_under "$main_dir" "$main_dir_name" "${cur#"$main_dir_name"/}"
      ;;
    *)
      # Default: complete relative to main_dir with no virtual prefix
      _dev_path_completion_under "$main_dir" "" "$cur"
      ;;
  esac

  return 0
}

# vscode cli wrapper alias
code() {
  local -a flags=()
  local -a paths=()

  for arg in "$@"; do
    if [[ "$arg" == -* ]]; then
      flags+=("$arg")
    else
      paths+=("$(_dev_path "$arg")")
    fi
  done

  if [[ ${#paths[@]} -eq 0 ]]; then
    command code "${flags[@]}"
    return
  fi

  # open all paths in one window on -r/--reuse-window
  local f
  for f in "${flags[@]}"; do
    if [[ "$f" == "-r" || "$f" == "--reuse-window" ]]; then
      command code "${flags[@]}" "${paths[@]}"
      return $?
    fi
  done

  # open every path in separate windows
  local rc=0
  local p
  for p in "${paths[@]}"; do
    command code "${flags[@]}" "$p" || rc=$?
  done

  return $rc
}
complete -F _dev_path_completion code

# glab clone group alias
alias dev-reclone="cd $(dirname $main_dir) && glab repo clone --group $gitlab_group --preserve-namespace --paginate $(basename $main_dir); cd -"
alias dev-clone="dev-reclone"

# create repo alias in $dev_dir
dev-alias() {
  mkdir -p $(dirname "$(_dev_path $2)")
  ln -s $(_dev_path $1) $(_dev_path $2)
}
complete -F _dev_path_completion dev-alias

# rm in $dev_dir
dev-rm() {
  local paths=()
  for arg in "$@"; do
    paths+=("$(_dev_path "$arg")")
  done
  rm -rf "${paths[@]}"
}
complete -F _dev_path_completion dev-rm

# cp in $dev_dir
dev-cp() {
  local paths=()
  for arg in "$@"; do
    paths+=("$(_dev_path "$arg")")
  done
  cp -r "${paths[@]}"
}
complete -F _dev_path_completion dev-cp

# mv in $dev_dir
dev-mv() {
  local paths=()
  for arg in "$@"; do
    paths+=("$(_dev_path "$arg")")
  done
  mv "${paths[@]}"
}
complete -F _dev_path_completion dev-mv

# mkdir in $dev_dir
dev-mkdir() {
  local paths=()
  for arg in "$@"; do
    paths+=("$(_dev_path "$arg")")
  done
  mkdir -p "${paths[@]}"
}
complete -F _dev_path_completion dev-mkdir

# cd in $dev_dir
dev-cd() {
  local paths=()
  for arg in "$@"; do
    paths+=("$(_dev_path "$arg")")
  done
  cd "${paths[@]}"
}
complete -F _dev_path_completion dev-cd

# list repo aliases in $dev_dir
dev-list-aliases() {
  find $dev_dir -type l -exec sh -c '
  for link; do
    target=$(readlink -f "$link") || continue
    [ -d "$target" ] || continue

    if [ -d "$target/.git" ]; then
      printf "%s -> %s\n" "$link" "$target"
      continue
    fi

    for d in "$target"/*; do
      [ -d "$d/.git" ] && {
        printf "%s -> %s\n" "$link" "$target"
        break
      }
    done
  done
  ' sh {} +
}

# btop alias
alias htop="echo use btop instead"

# delete empty directories
alias delete-empty-dirs="find . -type d -empty -delete"

# open in browser
browser() {
    local opener="${BROWSER:-xdg-open}"
    echo "Opening: $1"
    "$opener" "$1" >/dev/null 2>&1
}

# git goto main
gitmain() {
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  if [[ "$current_branch" != "main" && "$current_branch" != "master" ]]; then
    git fetch origin main:main || return 1
    git checkout main || return 1
  else
    git pull origin main || return 1
  fi
  delete-local-refs
}

# git open repo in browser
gitopen() {
    local dir="${1:-.}"
    dir="$(_dev_path "$dir")"
    
    # Verify it's a git repository
    if [[ ! -d "$dir/.git" ]]; then
        echo "Error: '$dir' is not a git repository." >&2
        return 1
    fi

    # Save current directory and switch to target
    local orig_dir="$(pwd)"
    cd "$dir" || return 1

    # normalize repo url
    local repo_url
    repo_url=$(git remote get-url origin)

    # normalize ssh (with and without protocol) and http urls
    if [[ "$repo_url" =~ ^ssh://git@(.+)\.git$ ]]; then
        repo_url="https://${BASH_REMATCH[1]}"
    elif [[ "$repo_url" =~ ^git@([^:]+):(.+)\.git$ ]]; then
        repo_url="https://${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    elif [[ "$repo_url" =~ ^https://.+\.git$ ]]; then
        repo_url="${repo_url%.git}"
    fi

    # Open Repo in browser
    browser "$repo_url"

    # return to original directory
    cd "$orig_dir"
}
complete -F _dev_path_completion gitopen

# git commit to branch helper
_git_branch_helper() {
  # convert commit message to branch syntax (e.g. "fix/something-again")
  # logic:
  #   sed: try converting ": " to "/" or keep original string
  #   tr: replace " " with "-"
  #   tr: convert to lowercase
  echo "$*" | sed -E 's/^([a-z]+):[[:space:]]*(.*)$/\1\/\2/' | tr ' ' '-' | tr '[:upper:]' '[:lower:]'
}

# git commit message completer
_git_commit_message_completion() {
  COMP_WORDBREAKS=${COMP_WORDBREAKS//:}
  # declare -p COMP_CWORD COMP_WORDS # DEBUG

  [[ $COMP_CWORD -eq 1 ]] &&
    COMPREPLY=( $(compgen -W "feat: chore: revert: fix: refactor: test: docs: style: perf:" -- "${COMP_WORDS[1]}") )
  [[ $COMP_CWORD -eq 2 ]] &&
    COMPREPLY=( $(compgen -W "add adjust rm remove include bump sw switch fix" -- "${COMP_WORDS[2]}") )
}

# git branch and commit
gitcb() {
    local message="$*" # something like "fix: something again"
    message=$(printf '%s\n' "$message" | sed 's/  */ /g') # normalize whitespaces

    if [[ -z "$message" ]]; then
        echo "Usage: gitcb \"<commit message>\""
        return 1
    fi

    # check if user is not currently on main
    local current_branch
    current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)

    if [[ "$current_branch" != "main" && "$current_branch" != "master" ]]; then
        echo "You are currently on branch: $current_branch."
        echo "Typically you use this command (git commit and branch) for a single commit change that requires branching."
        echo "If this wasn't intentional you might want to checkout main using 'gitmain'."
        read -rp "Continue creating a new branch from here? [y/N] " confirm
        case "$confirm" in
            [yY][eE][sS]|[yY]) ;;
            *) echo "Aborted."; return 1 ;;
        esac
    fi

    local branch=$(_git_branch_helper "$message") 

    git switch -c "$branch"
    git add .
    git commit -nm "$message"
    git push -u origin "$branch"

    gitopen
}
complete -F _git_commit_message_completion gitcb

# git branch
gitb() {
    local input="$*" # something like "fix: something again"
    input=$(printf '%s\n' "$input" | sed 's/  */ /g') # normalize whitespaces

    if [[ -z "$input" ]]; then
        echo "Usage: gitcb \"<branch name>\""
        return 1
    fi

    local branch=$(_git_branch_helper "$input") 

    git switch -c "$branch"
    git push -u origin "$branch"
}
complete -F _git_commit_message_completion gitb

# git commit
gitc() {
    local input="$*" # something like "fix: something again"
    input=$(printf '%s\n' "$input" | sed 's/  */ /g') # normalize whitespaces

    if [[ -z "$input" ]]; then
        echo "Usage: gitcb \"<commit message>\""
        return 1
    fi

    # check if user is not currently on main
    local current_branch
    current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)

    if [[ "$current_branch" == "main" || "$current_branch" == "master" ]]; then
        echo "You are currently on branch: $current_branch."
        echo "Typically you use this command (git commit) for creating a commit on a feature branch."
        echo "If this wasn't intentional you might want to create a branch (and commit) using 'gitb' or 'gitcb'"
        read -rp "Continue creating commit on main? [y/N] " confirm
        case "$confirm" in
            [yY][eE][sS]|[yY]) ;;
            *) echo "Aborted."; return 1 ;;
        esac
    fi

    git add .
    git commit -nm "$input"
    git push
}
complete -F _git_commit_message_completion gitc

# automatic semver tagging
gittag() {
  local type=$1
  local bump=$2

  if [[ -z "$type" || -z "$bump" ]]; then
    echo "Usage: gittag <release|rc> <major|minor|patch>"
    return 1
  fi

  git fetch --tags

  # get latest release tag (exclude RCs)
  local latest_release_tag
  latest_release_tag=$(git tag --list | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1)

  # set base version if no release tags exist
  if [[ -z "$latest_release_tag" ]]; then
    if [[ "$type" == "release" ]]; then
      latest_release_tag="0.0.0"
    else
      # for RC with no releases, use 0.0.0 as base
      latest_release_tag="0.0.0"
    fi
  fi

  IFS='.' read -r major minor patch <<< "$latest_release_tag"

  # bump the version appropriately
  case "$bump" in
    major)
      ((major++))
      minor=0
      patch=0
      ;;
    minor)
      ((minor++))
      patch=0
      ;;
    patch)
      ((patch++))
      ;;
    *)
      echo "Invalid bump type: $bump (must be major|minor|patch)"
      return 1
      ;;
  esac

  local new_tag base_rc latest_rc_tag rc_number warn_msg continue_msg
  base_rc="${major}.${minor}.${patch}"
  current_branch=$(git rev-parse --abbrev-ref HEAD)

  if [[ "$type" == "release" ]]; then
    new_tag="$base_rc"
    if [[ "$current_branch" != "main" && "$current_branch" != "master" ]]; then
      warn_msg="Your selected type 'release' is typically used on main/master branches.
If this wasn't intentional you might want to checkout main using 'gitmain'."
      continue_msg="Continue creating release tag on this commit? [y/N] "
    fi
  elif [[ "$type" == "rc" ]]; then
    # Match both "1.2.3rc1" and "1.2.3-rc1"
    latest_rc_tag=$(git tag --list | grep -E "^${base_rc}(-?rc)[0-9]+$" | sort -V | tail -n1)

    if [[ -z "$latest_rc_tag" ]]; then
      new_tag="${base_rc}-rc1"
    else
      # Extract rc number (works for both formats)
      rc_number=$(echo "$latest_rc_tag" | sed -E "s/^${base_rc}-?rc([0-9]+)$/\1/")
      ((rc_number++))
      new_tag="${base_rc}-rc${rc_number}"
    fi

    if [[ "$current_branch" == "main" || "$current_branch" == "master" ]]; then
      warn_msg="Your selected type 'rc' is typically used on feature branches.
If this wasn't intentional you might want to use the 'release' type."
      continue_msg="Continue creating rc tag on this commit? [y/N] "
    fi
  else
    echo "Invalid type: $type (must be release|rc)"
    return 1
  fi

  # If a warning was prepared, show it and confirm
  if [[ -n "$warn_msg" ]]; then
      echo "You are currently on branch: $current_branch."
      echo "$warn_msg"
      read -rp "$continue_msg" confirm
      case "$confirm" in
          [yY][eE][sS]|[yY]) ;;
          *) echo "Aborted."; return 1 ;;
      esac
  fi

  # create and push the tag
  git tag "$new_tag"
  git push origin "$new_tag"
  echo "Created tag: $new_tag"
}
_gittag_complete() {
  local cur prev
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  # first argument suggestions
  if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( $(compgen -W "release rc" -- "$cur") )
    return 0
  fi

  # second argument suggestions
  if [[ $COMP_CWORD -eq 2 ]]; then
    COMPREPLY=( $(compgen -W "major minor patch" -- "$cur") )
    return 0
  fi
}
complete -F _gittag_complete gittag

# flux reconcile ssp component
reconcilecomponent() {
  local component="${1:-$(basename "$(pwd)")}"
  echo "Reconciling: $component"
  flux reconcile kustomization --with-source gitrepositories
  flux reconcile kustomization --with-source ssp-namespaces
  flux reconcile kustomization --with-source $component
  flux reconcile helmrelease --with-source -n $component $component
}
